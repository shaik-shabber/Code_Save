{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nconst useStore = create(persist((set, get) => ({\n  // Authentication & UI state\n  user: null,\n  token: null,\n  topics: [],\n  selectedTopic: null,\n  selectedProblem: null,\n  isSidebarVisible: true,\n  isDarkMode: false,\n  searchResults: [],\n  isAuthenticated: false,\n  // Set user and token (user id is used for subsequent API calls)\n  setUser: (user, token = null) => set({\n    user,\n    token,\n    isAuthenticated: !!token\n  }),\n  // Clear persisted data on logout\n  logout: () => {\n    localStorage.removeItem('coding-notes-storage');\n    set({\n      user: null,\n      token: null,\n      isAuthenticated: false,\n      topics: []\n    });\n  },\n  // --------------------------\n  // TOPICS FUNCTIONS\n  // --------------------------\n\n  // Fetch all topics for the authenticated user\n  fetchTopics: async () => {\n    try {\n      const token = get().token;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/topics`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      if (res.ok) {\n        const topicsData = await res.json();\n        const formattedTopics = topicsData.map(topic => ({\n          topicId: topic.topicId || topic._id,\n          title: topic.title,\n          userId: topic.userId,\n          problems: topic.problems || {}\n        }));\n        set({\n          topics: formattedTopics\n        });\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to fetch topics:', errorText);\n      }\n    } catch (error) {\n      console.error('Error fetching topics:', error);\n    }\n  },\n  // Fetch a single topic by its topicId (for re-fetching details)\n  fetchTopic: async topicId => {\n    try {\n      const token = get().token;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/topics/${topicId}`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      if (res.ok) {\n        const topic = await res.json();\n        return {\n          topicId: topic.topicId || topic._id,\n          title: topic.title,\n          userId: topic.userId,\n          problems: topic.problems || {}\n        };\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to fetch topic:', errorText);\n      }\n    } catch (error) {\n      console.error('Error fetching topic:', error);\n    }\n  },\n  // Create a new topic with a generated topicId and a default picid\n  addTopic: async title => {\n    try {\n      const token = get().token;\n      const user = get().user;\n      const topicId = `${user._id}_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/topics`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          topicId,\n          title,\n          userId: user ? user._id : null,\n          picid: 'defaultPicId'\n        })\n      });\n      if (res.ok) {\n        const newTopic = await res.json();\n        set(state => ({\n          topics: [...state.topics, {\n            ...newTopic,\n            problems: {}\n          }]\n        }));\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to add topic:', errorText);\n      }\n    } catch (error) {\n      console.error('Error adding topic:', error);\n    }\n  },\n  // Delete a topic\n  deleteTopic: async topicId => {\n    try {\n      const token = get().token;\n      await fetch(`${process.env.REACT_APP_API_URL}/api/problems/topics/${topicId}`, {\n        method: 'DELETE',\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n    } catch (error) {\n      console.error('Error deleting topic on backend:', error);\n    }\n    set(state => ({\n      topics: state.topics.filter(topic => topic.topicId !== topicId)\n    }));\n  },\n  // --------------------------\n  // PROBLEMS FUNCTIONS\n  // --------------------------\n\n  // Fetch all problems and merge them into their topics\n  fetchProblems: async () => {\n    try {\n      const token = get().token;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      if (res.ok) {\n        const problems = await res.json();\n        set(state => {\n          const topics = state.topics.map(topic => ({\n            ...topic,\n            problems: {}\n          }));\n          problems.forEach(problem => {\n            const topicIndex = topics.findIndex(t => t.topicId === problem.topicId);\n            if (topicIndex > -1) {\n              topics[topicIndex].problems[problem.problemId] = problem;\n            } else {\n              topics.push({\n                topicId: problem.topicId,\n                title: problem.topicTitle || problem.topicId,\n                userId: problem.userId,\n                problems: {\n                  [problem.problemId]: problem\n                }\n              });\n            }\n          });\n          return {\n            topics\n          };\n        });\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to fetch problems:', errorText);\n      }\n    } catch (error) {\n      console.error('Error fetching problems:', error);\n    }\n  },\n  // Create a new problem. Returns the created problem.\n  createProblem: async problemData => {\n    try {\n      const user = get().user;\n      const token = get().token;\n      if (!user || !problemData.topicId) {\n        throw new Error(\"User or topicId missing\");\n      }\n      // Generate a unique problemId.\n      const randomPart = Math.random().toString(36).substring(2, 8);\n      const newProblemId = `${user._id}_${problemData.topicId}_${randomPart}`;\n      // Remove any provided problemId from problemData.\n      const {\n        problemId: ignore,\n        ...rest\n      } = problemData;\n      // Build payload explicitly.\n      const payload = {\n        ...rest,\n        userId: user._id,\n        topicId: problemData.topicId,\n        title: problemData.title,\n        statement: problemData.statement && problemData.statement.trim() !== \"\" ? problemData.statement : \"No statement provided\",\n        difficulty: problemData.difficulty,\n        constraints: problemData.constraints,\n        timeComplexity: problemData.timeComplexity,\n        spaceComplexity: problemData.spaceComplexity,\n        explanation: problemData.explanation && problemData.explanation.trim() !== \"\" ? problemData.explanation : \"No explanation provided\",\n        code: problemData.code && problemData.code.trim() !== \"\" ? problemData.code : \"// Code not provided\",\n        language: problemData.language,\n        problemId: newProblemId // Explicitly include our generated problemId.\n      };\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify(payload)\n      });\n      if (res.ok) {\n        const newProblem = await res.json();\n        set(state => {\n          const topics = [...state.topics];\n          const topicIndex = topics.findIndex(t => t.topicId === newProblem.topicId);\n          if (topicIndex > -1) {\n            topics[topicIndex] = {\n              ...topics[topicIndex],\n              problems: {\n                ...topics[topicIndex].problems,\n                [newProblem.problemId]: newProblem\n              }\n            };\n          } else {\n            topics.push({\n              topicId: newProblem.topicId,\n              title: problemData.topicTitle || newProblem.topicId,\n              userId: user._id,\n              problems: {\n                [newProblem.problemId]: newProblem\n              }\n            });\n          }\n          return {\n            topics\n          };\n        });\n        return newProblem;\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to create problem:', errorText);\n        throw new Error(errorText);\n      }\n    } catch (error) {\n      console.error('Error creating problem:', error);\n      throw error;\n    }\n  },\n  // Update a problem\n  updateProblem: async (topicId, problemId, updates) => {\n    try {\n      const token = get().token;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify(updates)\n      });\n      if (res.ok) {\n        const updatedProblem = await res.json();\n        set(state => ({\n          topics: state.topics.map(topic => topic.topicId === topicId ? {\n            ...topic,\n            problems: {\n              ...topic.problems,\n              [problemId]: updatedProblem\n            }\n          } : topic),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? updatedProblem : state.selectedProblem\n        }));\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to update problem:', errorText);\n      }\n    } catch (error) {\n      console.error('Error updating problem:', error);\n    }\n  },\n  // Delete a problem\n  deleteProblem: async (topicId, problemId) => {\n    try {\n      const token = get().token;\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\n        method: 'DELETE',\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      if (res.ok) {\n        set(state => {\n          const topics = state.topics.map(topic => {\n            if (topic.topicId === topicId) {\n              const newProblems = Object.fromEntries(Object.entries(topic.problems).filter(([key]) => key !== problemId));\n              return {\n                ...topic,\n                problems: newProblems\n              };\n            }\n            return topic;\n          });\n          return {\n            topics: topics.filter(topic => Object.keys(topic.problems).length > 0),\n            selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? null : state.selectedProblem\n          };\n        });\n      } else {\n        const errorText = await res.text();\n        console.error('Failed to delete problem:', errorText);\n      }\n    } catch (error) {\n      console.error('Error deleting problem:', error);\n    }\n  },\n  // Alias for creating a problem\n  addProblem: async (topicId, problemData) => {\n    return await get().createProblem({\n      ...problemData,\n      topicId\n    });\n  },\n  // --------------------------\n  // LOCAL SETTERS & UI HELPERS\n  // --------------------------\n  setTopics: topics => set({\n    topics\n  }),\n  setSelectedTopic: topic => set({\n    selectedTopic: topic\n  }),\n  setSelectedProblem: problem => set({\n    selectedProblem: problem\n  }),\n  toggleSidebar: () => set({\n    isSidebarVisible: !get().isSidebarVisible\n  }),\n  toggleDarkMode: () => {\n    const newDarkMode = !get().isDarkMode;\n    set({\n      isDarkMode: newDarkMode\n    });\n    document.documentElement.classList.toggle('dark', newDarkMode);\n  },\n  // --------------------------\n  // SEARCH & USER PREFERENCES\n  // --------------------------\n  searchProblems: query => {\n    const state = get();\n    if (!query.trim()) {\n      set({\n        searchResults: []\n      });\n      return;\n    }\n    const results = state.topics.flatMap(topic => Object.values(topic.problems).filter(problem => problem.title.toLowerCase().includes(query.toLowerCase()) || problem.statement.toLowerCase().includes(query.toLowerCase()) || problem.difficulty.toLowerCase() === query.toLowerCase()));\n    set({\n      searchResults: results\n    });\n  },\n  toggleFavorite: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/favorites`;\n      const res = await fetch(url, {\n        method: problem.isFavorite ? 'DELETE' : 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isFavorite: !topic.problems[problemId].isFavorite\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isFavorite: !state.selectedProblem.isFavorite\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling favorite:', error);\n    }\n  },\n  toggleSavedForLater: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/saved`;\n      const res = await fetch(url, {\n        method: problem.isSavedForLater ? 'DELETE' : 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isSavedForLater: !topic.problems[problemId].isSavedForLater\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isSavedForLater: !state.selectedProblem.isSavedForLater\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling saved for later:', error);\n    }\n  },\n  toggleSolved: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/solved`;\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isSolved: !topic.problems[problemId].isSolved\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isSolved: !state.selectedProblem.isSolved\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling solved:', error);\n    }\n  },\n  // --------------------------\n  // AUTHENTICATION HELPER\n  // --------------------------\n  verifyToken: async () => {\n    const token = get().token;\n    if (!token) return false;\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/auth/verify`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      return res.ok;\n    } catch (error) {\n      console.error('Error verifying token:', error);\n      return false;\n    }\n  }\n}), {\n  name: 'coding-notes-storage'\n}));\nexport default useStore;","map":{"version":3,"names":["create","persist","useStore","set","get","user","token","topics","selectedTopic","selectedProblem","isSidebarVisible","isDarkMode","searchResults","isAuthenticated","setUser","logout","localStorage","removeItem","fetchTopics","res","fetch","process","env","REACT_APP_API_URL","headers","Authorization","ok","topicsData","json","formattedTopics","map","topic","topicId","_id","title","userId","problems","errorText","text","console","error","fetchTopic","addTopic","Date","now","Math","random","toString","substring","method","body","JSON","stringify","picid","newTopic","state","deleteTopic","filter","fetchProblems","forEach","problem","topicIndex","findIndex","t","problemId","push","topicTitle","createProblem","problemData","Error","randomPart","newProblemId","ignore","rest","payload","statement","trim","difficulty","constraints","timeComplexity","spaceComplexity","explanation","code","language","newProblem","updateProblem","updates","updatedProblem","deleteProblem","newProblems","Object","fromEntries","entries","key","keys","length","addProblem","setTopics","setSelectedTopic","setSelectedProblem","toggleSidebar","toggleDarkMode","newDarkMode","document","documentElement","classList","toggle","searchProblems","query","results","flatMap","values","toLowerCase","includes","toggleFavorite","url","isFavorite","toggleSavedForLater","isSavedForLater","toggleSolved","isSolved","verifyToken","name"],"sources":["D:/FInal Projects/CodeSave/frontend/src/store/useStore.js"],"sourcesContent":["import { create } from 'zustand';\r\nimport { persist } from 'zustand/middleware';\r\n\r\nconst useStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      // Authentication & UI state\r\n      user: null,\r\n      token: null,\r\n      topics: [],\r\n      selectedTopic: null,\r\n      selectedProblem: null,\r\n      isSidebarVisible: true,\r\n      isDarkMode: false,\r\n      searchResults: [],\r\n      isAuthenticated: false,\r\n\r\n      // Set user and token (user id is used for subsequent API calls)\r\n      setUser: (user, token = null) =>\r\n        set({ user, token, isAuthenticated: !!token }),\r\n\r\n      // Clear persisted data on logout\r\n      logout: () => {\r\n        localStorage.removeItem('coding-notes-storage');\r\n        set({ user: null, token: null, isAuthenticated: false, topics: [] });\r\n      },\r\n\r\n      // --------------------------\r\n      // TOPICS FUNCTIONS\r\n      // --------------------------\r\n\r\n      // Fetch all topics for the authenticated user\r\n      fetchTopics: async () => {\r\n        try {\r\n          const token = get().token;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/topics`,\r\n            { headers: { Authorization: `Bearer ${token}` } }\r\n          );\r\n          if (res.ok) {\r\n            const topicsData = await res.json();\r\n            const formattedTopics = topicsData.map((topic) => ({\r\n              topicId: topic.topicId || topic._id,\r\n              title: topic.title,\r\n              userId: topic.userId,\r\n              problems: topic.problems || {},\r\n            }));\r\n            set({ topics: formattedTopics });\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to fetch topics:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error fetching topics:', error);\r\n        }\r\n      },\r\n\r\n      // Fetch a single topic by its topicId (for re-fetching details)\r\n      fetchTopic: async (topicId) => {\r\n        try {\r\n          const token = get().token;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/topics/${topicId}`,\r\n            { headers: { Authorization: `Bearer ${token}` } }\r\n          );\r\n          if (res.ok) {\r\n            const topic = await res.json();\r\n            return {\r\n              topicId: topic.topicId || topic._id,\r\n              title: topic.title,\r\n              userId: topic.userId,\r\n              problems: topic.problems || {},\r\n            };\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to fetch topic:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error fetching topic:', error);\r\n        }\r\n      },\r\n\r\n      // Create a new topic with a generated topicId and a default picid\r\n      addTopic: async (title) => {\r\n        try {\r\n          const token = get().token;\r\n          const user = get().user;\r\n          const topicId = `${user._id}_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/topics`,\r\n            {\r\n              method: 'POST',\r\n              headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${token}`,\r\n              },\r\n              body: JSON.stringify({\r\n                topicId,\r\n                title,\r\n                userId: user ? user._id : null,\r\n                picid: 'defaultPicId',\r\n              }),\r\n            }\r\n          );\r\n          if (res.ok) {\r\n            const newTopic = await res.json();\r\n            set((state) => ({\r\n              topics: [...state.topics, { ...newTopic, problems: {} }],\r\n            }));\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to add topic:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error adding topic:', error);\r\n        }\r\n      },\r\n\r\n      // Delete a topic\r\n      deleteTopic: async (topicId) => {\r\n        try {\r\n          const token = get().token;\r\n          await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/topics/${topicId}`,\r\n            {\r\n              method: 'DELETE',\r\n              headers: { Authorization: `Bearer ${token}` },\r\n            }\r\n          );\r\n        } catch (error) {\r\n          console.error('Error deleting topic on backend:', error);\r\n        }\r\n        set((state) => ({\r\n          topics: state.topics.filter((topic) => topic.topicId !== topicId),\r\n        }));\r\n      },\r\n\r\n      // --------------------------\r\n      // PROBLEMS FUNCTIONS\r\n      // --------------------------\r\n\r\n      // Fetch all problems and merge them into their topics\r\n      fetchProblems: async () => {\r\n        try {\r\n          const token = get().token;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems`,\r\n            { headers: { Authorization: `Bearer ${token}` } }\r\n          );\r\n          if (res.ok) {\r\n            const problems = await res.json();\r\n            set((state) => {\r\n              const topics = state.topics.map((topic) => ({\r\n                ...topic,\r\n                problems: {},\r\n              }));\r\n              problems.forEach((problem) => {\r\n                const topicIndex = topics.findIndex(\r\n                  (t) => t.topicId === problem.topicId\r\n                );\r\n                if (topicIndex > -1) {\r\n                  topics[topicIndex].problems[problem.problemId] = problem;\r\n                } else {\r\n                  topics.push({\r\n                    topicId: problem.topicId,\r\n                    title: problem.topicTitle || problem.topicId,\r\n                    userId: problem.userId,\r\n                    problems: { [problem.problemId]: problem },\r\n                  });\r\n                }\r\n              });\r\n              return { topics };\r\n            });\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to fetch problems:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error fetching problems:', error);\r\n        }\r\n      },\r\n\r\n      // Create a new problem. Returns the created problem.\r\n      createProblem: async (problemData) => {\r\n        try {\r\n          const user = get().user;\r\n          const token = get().token;\r\n          if (!user || !problemData.topicId) {\r\n            throw new Error(\"User or topicId missing\");\r\n          }\r\n          // Generate a unique problemId.\r\n          const randomPart = Math.random().toString(36).substring(2, 8);\r\n          const newProblemId = `${user._id}_${problemData.topicId}_${randomPart}`;\r\n          // Remove any provided problemId from problemData.\r\n          const { problemId: ignore, ...rest } = problemData;\r\n          // Build payload explicitly.\r\n          const payload = {\r\n            ...rest,\r\n            userId: user._id,\r\n            topicId: problemData.topicId,\r\n            title: problemData.title,\r\n            statement:\r\n              problemData.statement && problemData.statement.trim() !== \"\"\r\n                ? problemData.statement\r\n                : \"No statement provided\",\r\n            difficulty: problemData.difficulty,\r\n            constraints: problemData.constraints,\r\n            timeComplexity: problemData.timeComplexity,\r\n            spaceComplexity: problemData.spaceComplexity,\r\n            explanation:\r\n              problemData.explanation && problemData.explanation.trim() !== \"\"\r\n                ? problemData.explanation\r\n                : \"No explanation provided\",\r\n            code:\r\n              problemData.code && problemData.code.trim() !== \"\"\r\n                ? problemData.code\r\n                : \"// Code not provided\",\r\n            language: problemData.language,\r\n            problemId: newProblemId, // Explicitly include our generated problemId.\r\n          };\r\n\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems`,\r\n            {\r\n              method: 'POST',\r\n              headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${token}`,\r\n              },\r\n              body: JSON.stringify(payload),\r\n            }\r\n          );\r\n          if (res.ok) {\r\n            const newProblem = await res.json();\r\n            set((state) => {\r\n              const topics = [...state.topics];\r\n              const topicIndex = topics.findIndex(\r\n                (t) => t.topicId === newProblem.topicId\r\n              );\r\n              if (topicIndex > -1) {\r\n                topics[topicIndex] = {\r\n                  ...topics[topicIndex],\r\n                  problems: {\r\n                    ...topics[topicIndex].problems,\r\n                    [newProblem.problemId]: newProblem,\r\n                  },\r\n                };\r\n              } else {\r\n                topics.push({\r\n                  topicId: newProblem.topicId,\r\n                  title: problemData.topicTitle || newProblem.topicId,\r\n                  userId: user._id,\r\n                  problems: { [newProblem.problemId]: newProblem },\r\n                });\r\n              }\r\n              return { topics };\r\n            });\r\n            return newProblem;\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to create problem:', errorText);\r\n            throw new Error(errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error creating problem:', error);\r\n          throw error;\r\n        }\r\n      },\r\n\r\n      // Update a problem\r\n      updateProblem: async (topicId, problemId, updates) => {\r\n        try {\r\n          const token = get().token;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/${problemId}`,\r\n            {\r\n              method: 'PUT',\r\n              headers: {\r\n                'Content-Type': 'application/json',\r\n                Authorization: `Bearer ${token}`,\r\n              },\r\n              body: JSON.stringify(updates),\r\n            }\r\n          );\r\n          if (res.ok) {\r\n            const updatedProblem = await res.json();\r\n            set((state) => ({\r\n              topics: state.topics.map((topic) =>\r\n                topic.topicId === topicId\r\n                  ? {\r\n                      ...topic,\r\n                      problems: {\r\n                        ...topic.problems,\r\n                        [problemId]: updatedProblem,\r\n                      },\r\n                    }\r\n                  : topic\r\n              ),\r\n              selectedProblem:\r\n                state.selectedProblem &&\r\n                state.selectedProblem.problemId === problemId\r\n                  ? updatedProblem\r\n                  : state.selectedProblem,\r\n            }));\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to update problem:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error updating problem:', error);\r\n        }\r\n      },\r\n\r\n      // Delete a problem\r\n      deleteProblem: async (topicId, problemId) => {\r\n        try {\r\n          const token = get().token;\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/problems/${problemId}`,\r\n            {\r\n              method: 'DELETE',\r\n              headers: { Authorization: `Bearer ${token}` },\r\n            }\r\n          );\r\n          if (res.ok) {\r\n            set((state) => {\r\n              const topics = state.topics.map((topic) => {\r\n                if (topic.topicId === topicId) {\r\n                  const newProblems = Object.fromEntries(\r\n                    Object.entries(topic.problems).filter(\r\n                      ([key]) => key !== problemId\r\n                    )\r\n                  );\r\n                  return { ...topic, problems: newProblems };\r\n                }\r\n                return topic;\r\n              });\r\n              return {\r\n                topics: topics.filter(\r\n                  (topic) => Object.keys(topic.problems).length > 0\r\n                ),\r\n                selectedProblem:\r\n                  state.selectedProblem &&\r\n                  state.selectedProblem.problemId === problemId\r\n                    ? null\r\n                    : state.selectedProblem,\r\n              };\r\n            });\r\n          } else {\r\n            const errorText = await res.text();\r\n            console.error('Failed to delete problem:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error deleting problem:', error);\r\n        }\r\n      },\r\n\r\n      // Alias for creating a problem\r\n      addProblem: async (topicId, problemData) => {\r\n        return await get().createProblem({ ...problemData, topicId });\r\n      },\r\n\r\n      // --------------------------\r\n      // LOCAL SETTERS & UI HELPERS\r\n      // --------------------------\r\n      setTopics: (topics) => set({ topics }),\r\n      setSelectedTopic: (topic) => set({ selectedTopic: topic }),\r\n      setSelectedProblem: (problem) => set({ selectedProblem: problem }),\r\n\r\n      toggleSidebar: () =>\r\n        set({ isSidebarVisible: !get().isSidebarVisible }),\r\n\r\n      toggleDarkMode: () => {\r\n        const newDarkMode = !get().isDarkMode;\r\n        set({ isDarkMode: newDarkMode });\r\n        document.documentElement.classList.toggle('dark', newDarkMode);\r\n      },\r\n\r\n      // --------------------------\r\n      // SEARCH & USER PREFERENCES\r\n      // --------------------------\r\n      searchProblems: (query) => {\r\n        const state = get();\r\n        if (!query.trim()) {\r\n          set({ searchResults: [] });\r\n          return;\r\n        }\r\n        const results = state.topics.flatMap((topic) =>\r\n          Object.values(topic.problems).filter(\r\n            (problem) =>\r\n              problem.title.toLowerCase().includes(query.toLowerCase()) ||\r\n              problem.statement.toLowerCase().includes(query.toLowerCase()) ||\r\n              problem.difficulty.toLowerCase() === query.toLowerCase()\r\n          )\r\n        );\r\n        set({ searchResults: results });\r\n      },\r\n\r\n      toggleFavorite: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/favorites`;\r\n          const res = await fetch(url, {\r\n            method: problem.isFavorite ? 'DELETE' : 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map((topic) => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isFavorite: !topic.problems[problemId].isFavorite,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem &&\r\n                state.selectedProblem.problemId === problemId\r\n                  ? {\r\n                      ...state.selectedProblem,\r\n                      isFavorite: !state.selectedProblem.isFavorite,\r\n                    }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling favorite:', error);\r\n        }\r\n      },\r\n\r\n      toggleSavedForLater: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/saved`;\r\n          const res = await fetch(url, {\r\n            method: problem.isSavedForLater ? 'DELETE' : 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map((topic) => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isSavedForLater: !topic.problems[problemId].isSavedForLater,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem &&\r\n                state.selectedProblem.problemId === problemId\r\n                  ? {\r\n                      ...state.selectedProblem,\r\n                      isSavedForLater: !state.selectedProblem.isSavedForLater,\r\n                    }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling saved for later:', error);\r\n        }\r\n      },\r\n\r\n      toggleSolved: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/solved`;\r\n          const res = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map((topic) => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isSolved: !topic.problems[problemId].isSolved,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem &&\r\n                state.selectedProblem.problemId === problemId\r\n                  ? {\r\n                      ...state.selectedProblem,\r\n                      isSolved: !state.selectedProblem.isSolved,\r\n                    }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling solved:', error);\r\n        }\r\n      },\r\n\r\n      // --------------------------\r\n      // AUTHENTICATION HELPER\r\n      // --------------------------\r\n      verifyToken: async () => {\r\n        const token = get().token;\r\n        if (!token) return false;\r\n        try {\r\n          const res = await fetch(\r\n            `${process.env.REACT_APP_API_URL}/api/auth/verify`,\r\n            { headers: { Authorization: `Bearer ${token}` } }\r\n          );\r\n          return res.ok;\r\n        } catch (error) {\r\n          console.error('Error verifying token:', error);\r\n          return false;\r\n        }\r\n      },\r\n    }),\r\n    { name: 'coding-notes-storage' }\r\n  )\r\n);\r\n\r\nexport default useStore;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}