{"ast":null,"code":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nconst useStore = create(persist((set, get) => ({\n  user: null,\n  token: null,\n  topics: [],\n  selectedTopic: null,\n  selectedProblem: null,\n  isSidebarVisible: true,\n  isDarkMode: false,\n  searchResults: [],\n  isAuthenticated: false,\n  // Set the user and token; mark as authenticated if token exists\n  setUser: (user, token = null) => set({\n    user,\n    token,\n    isAuthenticated: !!token\n  }),\n  // Clear user and token and remove persisted data\n  logout: () => {\n    localStorage.removeItem('coding-notes-storage');\n    set({\n      user: null,\n      token: null,\n      isAuthenticated: false\n    });\n  },\n  // Fetch all problems from the backend and group them by topicId\n  fetchProblems: async () => {\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`);\n      if (res.ok) {\n        const problems = await res.json();\n        // Group problems by topicId. (If your problems include a topicTitle, use it.)\n        const topicsMap = {};\n        problems.forEach(problem => {\n          const {\n            topicId\n          } = problem;\n          if (!topicsMap[topicId]) {\n            topicsMap[topicId] = {\n              topicId,\n              title: problem.topicTitle || 'Unknown',\n              problems: {}\n            };\n          }\n          topicsMap[topicId].problems[problem.problemId] = problem;\n        });\n        set({\n          topics: Object.values(topicsMap)\n        });\n      }\n    } catch (error) {\n      console.error(\"Error fetching problems:\", error);\n    }\n  },\n  // Create a new problem via the backend\n  createProblem: async problemData => {\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(problemData)\n      });\n      if (res.ok) {\n        const newProblem = await res.json();\n        // Update local state: add the new problem to its topic\n        set(state => ({\n          topics: state.topics.map(topic => topic.topicId === newProblem.topicId ? {\n            ...topic,\n            problems: {\n              ...topic.problems,\n              [newProblem.problemId]: newProblem\n            }\n          } : topic)\n        }));\n      }\n    } catch (error) {\n      console.error(\"Error creating problem:\", error);\n    }\n  },\n  // Update a problem via the backend\n  updateProblem: async (topicId, problemId, updates) => {\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updates)\n      });\n      if (res.ok) {\n        const updatedProblem = await res.json();\n        set(state => ({\n          topics: state.topics.map(topic => topic.topicId === topicId ? {\n            ...topic,\n            problems: {\n              ...topic.problems,\n              [problemId]: updatedProblem\n            }\n          } : topic),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? updatedProblem : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error(\"Error updating problem:\", error);\n    }\n  },\n  // Delete a problem via the backend\n  deleteProblem: async (topicId, problemId) => {\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\n        method: 'DELETE'\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => topic.topicId === topicId ? {\n            ...topic,\n            problems: Object.fromEntries(Object.entries(topic.problems).filter(([key]) => key !== problemId))\n          } : topic),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? null : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error(\"Error deleting problem:\", error);\n    }\n  },\n  // Local setters for topics, selectedTopic, and selectedProblem\n  setTopics: topics => set({\n    topics\n  }),\n  setSelectedTopic: topic => set({\n    selectedTopic: topic\n  }),\n  setSelectedProblem: problem => set({\n    selectedProblem: problem\n  }),\n  toggleSidebar: () => set({\n    isSidebarVisible: !get().isSidebarVisible\n  }),\n  toggleDarkMode: () => {\n    const newDarkMode = !get().isDarkMode;\n    set({\n      isDarkMode: newDarkMode\n    });\n    document.documentElement.classList.toggle('dark', newDarkMode);\n  },\n  // Search problems locally in the store\n  searchProblems: query => {\n    const state = get();\n    if (!query.trim()) {\n      set({\n        searchResults: []\n      });\n      return;\n    }\n    const results = state.topics.flatMap(topic => Object.values(topic.problems).filter(problem => problem.title.toLowerCase().includes(query.toLowerCase()) || problem.statement.toLowerCase().includes(query.toLowerCase()) || problem.difficulty.toLowerCase() === query.toLowerCase()));\n    set({\n      searchResults: results\n    });\n  },\n  // Toggle Favorite via the user endpoint\n  toggleFavorite: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/favorites`;\n      const method = problem.isFavorite ? 'DELETE' : 'POST';\n      const res = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isFavorite: !topic.problems[problemId].isFavorite\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isFavorite: !state.selectedProblem.isFavorite\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling favorite:', error);\n    }\n  },\n  // Toggle Saved For Later via the user endpoint\n  toggleSavedForLater: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/saved`;\n      const method = problem.isSavedForLater ? 'DELETE' : 'POST';\n      const res = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isSavedForLater: !topic.problems[problemId].isSavedForLater\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isSavedForLater: !state.selectedProblem.isSavedForLater\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling saved for later:', error);\n    }\n  },\n  // Toggle Solved via the user endpoint (using POST as per your routes)\n  toggleSolved: async problemId => {\n    try {\n      const state = get();\n      let problem;\n      for (const topic of state.topics) {\n        if (topic.problems[problemId]) {\n          problem = topic.problems[problemId];\n          break;\n        }\n      }\n      if (!problem) return;\n      const token = state.token;\n      const url = `${process.env.REACT_APP_API_URL}/api/users/solved`;\n      const res = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          problemId\n        })\n      });\n      if (res.ok) {\n        set(state => ({\n          topics: state.topics.map(topic => {\n            if (topic.problems[problemId]) {\n              return {\n                ...topic,\n                problems: {\n                  ...topic.problems,\n                  [problemId]: {\n                    ...topic.problems[problemId],\n                    isSolved: !topic.problems[problemId].isSolved\n                  }\n                }\n              };\n            }\n            return topic;\n          }),\n          selectedProblem: state.selectedProblem && state.selectedProblem.problemId === problemId ? {\n            ...state.selectedProblem,\n            isSolved: !state.selectedProblem.isSolved\n          } : state.selectedProblem\n        }));\n      }\n    } catch (error) {\n      console.error('Error toggling solved:', error);\n    }\n  },\n  // Verify token via backend\n  verifyToken: async () => {\n    const token = get().token;\n    if (!token) return false;\n    try {\n      const res = await fetch(`${process.env.REACT_APP_API_URL}/api/auth/verify`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      return res.ok;\n    } catch (error) {\n      console.error('Error verifying token:', error);\n      return false;\n    }\n  }\n}), {\n  name: 'coding-notes-storage'\n}));\nexport default useStore;","map":{"version":3,"names":["create","persist","useStore","set","get","user","token","topics","selectedTopic","selectedProblem","isSidebarVisible","isDarkMode","searchResults","isAuthenticated","setUser","logout","localStorage","removeItem","fetchProblems","res","fetch","process","env","REACT_APP_API_URL","ok","problems","json","topicsMap","forEach","problem","topicId","title","topicTitle","problemId","Object","values","error","console","createProblem","problemData","method","headers","body","JSON","stringify","newProblem","state","map","topic","updateProblem","updates","updatedProblem","deleteProblem","fromEntries","entries","filter","key","setTopics","setSelectedTopic","setSelectedProblem","toggleSidebar","toggleDarkMode","newDarkMode","document","documentElement","classList","toggle","searchProblems","query","trim","results","flatMap","toLowerCase","includes","statement","difficulty","toggleFavorite","url","isFavorite","Authorization","toggleSavedForLater","isSavedForLater","toggleSolved","isSolved","verifyToken","name"],"sources":["D:/FInal Projects/CodeSave/frontend/src/store/useStore.js"],"sourcesContent":["import { create } from 'zustand';\r\nimport { persist } from 'zustand/middleware';\r\n\r\nconst useStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      user: null,\r\n      token: null,\r\n      topics: [],\r\n      selectedTopic: null,\r\n      selectedProblem: null,\r\n      isSidebarVisible: true,\r\n      isDarkMode: false,\r\n      searchResults: [],\r\n      isAuthenticated: false,\r\n\r\n      // Set the user and token; mark as authenticated if token exists\r\n      setUser: (user, token = null) =>\r\n        set({ user, token, isAuthenticated: !!token }),\r\n\r\n      // Clear user and token and remove persisted data\r\n      logout: () => {\r\n        localStorage.removeItem('coding-notes-storage');\r\n        set({ user: null, token: null, isAuthenticated: false });\r\n      },\r\n\r\n      // Fetch all problems from the backend and group them by topicId\r\n      fetchProblems: async () => {\r\n        try {\r\n          const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`);\r\n          if (res.ok) {\r\n            const problems = await res.json();\r\n            // Group problems by topicId. (If your problems include a topicTitle, use it.)\r\n            const topicsMap = {};\r\n            problems.forEach(problem => {\r\n              const { topicId } = problem;\r\n              if (!topicsMap[topicId]) {\r\n                topicsMap[topicId] = { topicId, title: problem.topicTitle || 'Unknown', problems: {} };\r\n              }\r\n              topicsMap[topicId].problems[problem.problemId] = problem;\r\n            });\r\n            set({ topics: Object.values(topicsMap) });\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error fetching problems:\", error);\r\n        }\r\n      },\r\n\r\n      // Create a new problem via the backend\r\n      createProblem: async (problemData) => {\r\n        try {\r\n          const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems`, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(problemData),\r\n          });\r\n          if (res.ok) {\r\n            const newProblem = await res.json();\r\n            // Update local state: add the new problem to its topic\r\n            set((state) => ({\r\n              topics: state.topics.map(topic =>\r\n                topic.topicId === newProblem.topicId\r\n                  ? {\r\n                      ...topic,\r\n                      problems: {\r\n                        ...topic.problems,\r\n                        [newProblem.problemId]: newProblem,\r\n                      },\r\n                    }\r\n                  : topic\r\n              ),\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error creating problem:\", error);\r\n        }\r\n      },\r\n\r\n      // Update a problem via the backend\r\n      updateProblem: async (topicId, problemId, updates) => {\r\n        try {\r\n          const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\r\n            method: 'PUT',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(updates),\r\n          });\r\n          if (res.ok) {\r\n            const updatedProblem = await res.json();\r\n            set((state) => ({\r\n              topics: state.topics.map(topic =>\r\n                topic.topicId === topicId\r\n                  ? {\r\n                      ...topic,\r\n                      problems: {\r\n                        ...topic.problems,\r\n                        [problemId]: updatedProblem,\r\n                      },\r\n                    }\r\n                  : topic\r\n              ),\r\n              selectedProblem:\r\n                state.selectedProblem && state.selectedProblem.problemId === problemId\r\n                  ? updatedProblem\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error updating problem:\", error);\r\n        }\r\n      },\r\n\r\n      // Delete a problem via the backend\r\n      deleteProblem: async (topicId, problemId) => {\r\n        try {\r\n          const res = await fetch(`${process.env.REACT_APP_API_URL}/api/problems/${problemId}`, {\r\n            method: 'DELETE',\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map(topic =>\r\n                topic.topicId === topicId\r\n                  ? {\r\n                      ...topic,\r\n                      problems: Object.fromEntries(\r\n                        Object.entries(topic.problems).filter(([key]) => key !== problemId)\r\n                      ),\r\n                    }\r\n                  : topic\r\n              ),\r\n              selectedProblem:\r\n                state.selectedProblem && state.selectedProblem.problemId === problemId\r\n                  ? null\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error deleting problem:\", error);\r\n        }\r\n      },\r\n\r\n      // Local setters for topics, selectedTopic, and selectedProblem\r\n      setTopics: (topics) => set({ topics }),\r\n      setSelectedTopic: (topic) => set({ selectedTopic: topic }),\r\n      setSelectedProblem: (problem) => set({ selectedProblem: problem }),\r\n\r\n      toggleSidebar: () => set({ isSidebarVisible: !get().isSidebarVisible }),\r\n\r\n      toggleDarkMode: () => {\r\n        const newDarkMode = !get().isDarkMode;\r\n        set({ isDarkMode: newDarkMode });\r\n        document.documentElement.classList.toggle('dark', newDarkMode);\r\n      },\r\n\r\n      // Search problems locally in the store\r\n      searchProblems: (query) => {\r\n        const state = get();\r\n        if (!query.trim()) {\r\n          set({ searchResults: [] });\r\n          return;\r\n        }\r\n        const results = state.topics.flatMap((topic) =>\r\n          Object.values(topic.problems).filter(\r\n            (problem) =>\r\n              problem.title.toLowerCase().includes(query.toLowerCase()) ||\r\n              problem.statement.toLowerCase().includes(query.toLowerCase()) ||\r\n              problem.difficulty.toLowerCase() === query.toLowerCase()\r\n          )\r\n        );\r\n        set({ searchResults: results });\r\n      },\r\n\r\n      // Toggle Favorite via the user endpoint\r\n      toggleFavorite: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/favorites`;\r\n          const method = problem.isFavorite ? 'DELETE' : 'POST';\r\n          const res = await fetch(url, {\r\n            method,\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map(topic => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isFavorite: !topic.problems[problemId].isFavorite,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem && state.selectedProblem.problemId === problemId\r\n                  ? { ...state.selectedProblem, isFavorite: !state.selectedProblem.isFavorite }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling favorite:', error);\r\n        }\r\n      },\r\n\r\n      // Toggle Saved For Later via the user endpoint\r\n      toggleSavedForLater: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/saved`;\r\n          const method = problem.isSavedForLater ? 'DELETE' : 'POST';\r\n          const res = await fetch(url, {\r\n            method,\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map(topic => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isSavedForLater: !topic.problems[problemId].isSavedForLater,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem && state.selectedProblem.problemId === problemId\r\n                  ? { ...state.selectedProblem, isSavedForLater: !state.selectedProblem.isSavedForLater }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling saved for later:', error);\r\n        }\r\n      },\r\n\r\n      // Toggle Solved via the user endpoint (using POST as per your routes)\r\n      toggleSolved: async (problemId) => {\r\n        try {\r\n          const state = get();\r\n          let problem;\r\n          for (const topic of state.topics) {\r\n            if (topic.problems[problemId]) {\r\n              problem = topic.problems[problemId];\r\n              break;\r\n            }\r\n          }\r\n          if (!problem) return;\r\n          const token = state.token;\r\n          const url = `${process.env.REACT_APP_API_URL}/api/users/solved`;\r\n          const res = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              Authorization: `Bearer ${token}`,\r\n            },\r\n            body: JSON.stringify({ problemId }),\r\n          });\r\n          if (res.ok) {\r\n            set((state) => ({\r\n              topics: state.topics.map(topic => {\r\n                if (topic.problems[problemId]) {\r\n                  return {\r\n                    ...topic,\r\n                    problems: {\r\n                      ...topic.problems,\r\n                      [problemId]: {\r\n                        ...topic.problems[problemId],\r\n                        isSolved: !topic.problems[problemId].isSolved,\r\n                      },\r\n                    },\r\n                  };\r\n                }\r\n                return topic;\r\n              }),\r\n              selectedProblem:\r\n                state.selectedProblem && state.selectedProblem.problemId === problemId\r\n                  ? { ...state.selectedProblem, isSolved: !state.selectedProblem.isSolved }\r\n                  : state.selectedProblem,\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('Error toggling solved:', error);\r\n        }\r\n      },\r\n\r\n      // Verify token via backend\r\n      verifyToken: async () => {\r\n        const token = get().token;\r\n        if (!token) return false;\r\n        try {\r\n          const res = await fetch(`${process.env.REACT_APP_API_URL}/api/auth/verify`, {\r\n            headers: { Authorization: `Bearer ${token}` },\r\n          });\r\n          return res.ok;\r\n        } catch (error) {\r\n          console.error('Error verifying token:', error);\r\n          return false;\r\n        }\r\n      },\r\n    }),\r\n    { name: 'coding-notes-storage' }\r\n  )\r\n);\r\n\r\nexport default useStore;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}